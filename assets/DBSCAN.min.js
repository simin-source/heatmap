/* min from https://www.toptal.com/developers/javascript-minifier */
class DBSCAN {
    constructor(a, b, c="Euclidean", d) {
        this.allow_distance = ["Euclidean"],
        this.eps(a),
        this.min_point(b),
        this.distance(c),
        this.data(d)
    }
    eps(a) {
        if (void 0 === a || "number" == typeof a)
            return this._eps = a,
            this;
        throw "eps should pass number"
    }
    min_point(a) {
        if (void 0 === a || "number" == typeof a)
            return this._min_point = a,
            this;
        throw "min_point should pass number"
    }
    distance(a) {
        if (void 0 === a || "string" == typeof a || this.allow_distance.indexOf(a) >= 0) {
            if (void 0 !== a)
                return 0 === this.allow_distance.indexOf(a) && (this._distance = this.euclidean),
                this
        } else
            throw `distance should pass [${this.allow_distance}]`
    }
    set_distance_function(a) {
        return this._distance = a,
        this
    }
    data(a) {
        if (void 0 === a || "Array" === a.constructor.name || "Object" === a.constructor.name) {
            if (void 0 !== a) {
                let b = 0;
                for (let c in a) {
                    if ("Array" != a[c].constructor.name && "Object" != a[c].constructor.name)
                        throw "data should is 2-dim array or object";
                    b++;
                    break
                }
                if (0 === b)
                    throw "data should have element";
                for (let d in this._data = new Array,
                a)
                    this._data.push(new dbscan_struct(a[d]))
            }
            return this
        }
        throw "data should pass array"
    }
    fit(e) {
        if (void 0 !== e && this.data(e),
        void 0 === this._eps)
            throw "miss pass eps";
        if (void 0 === this._min_point)
            throw "miss pass min_point";
        if (void 0 === this._distance)
            throw "miss pass distance";
        if (void 0 === this._data)
            throw "miss pass data";
        let c = 1;
        for (let d in this._data) {
            if (void 0 != this._data[d].label)
                continue;
            let a = this._get_neighbors(d);
            if (a.length < this._min_point) {
                this._data[d].label = "noise";
                continue
            }
            for (let b in this._data[d].label = c,
            a) {
                if ("noise" == this._data[a[b]].label && (this._data[a[b]].label = c),
                void 0 != this._data[a[b]].label)
                    continue;
                this._data[a[b]].label = c;
                let f = this._get_neighbors(a[b]);
                f.length >= this._min_point && a.concat(f)
            }
            c++
        }
        return this._get_result()
    }
    _get_result() {
        let a = new Object;
        for (let c in this._data) {
            let b = this._data[c].label
              , d = this._data[c].vector;
            b in a || (a[b] = new Array),
            a[b].push(d)
        }
        return a
    }
    _get_neighbors(b) {
        let c = new Array;
        for (let a in this._data)
            a != b && this._distance(this._data[a].vector, this._data[b].vector) <= this._eps && c.push(a);
        return c
    }
    euclidean(a, d) {
        let b = 0;
        for (let c in a)
            b += Math.pow(a[c] - d[c], 2);
        return Math.sqrt(b)
    }
}
class dbscan_struct {
    constructor(a) {
        this.vector = a,
        this.label = void 0
    }
}
